class Solution {
    public boolean wildCard(String s, String p) {
        int n = s.length();
        int m = p.length();
        
        // Create two 1D arrays, prev and curr, for dynamic programming
        boolean[] prev = new boolean[m + 1];
        boolean[] curr = new boolean[m + 1];

        // Initialize base case for empty string matching with the pattern
        prev[0] = true;

        // Initialize dp array for the case where pattern consists of only '*'
        for (int j = 1; j <= m; j++) {
            prev[j] = prev[j - 1] && p.charAt(j - 1) == '*';
        }

        // Iterate through each character of the string
        for (int i = 1; i <= n; i++) {
            // Set current row for dp
            curr[0] = false;  // If the string is non-empty, it cannot match an empty pattern

            // Iterate through each character of the pattern
            for (int j = 1; j <= m; j++) {
                if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '?') {
                    // If characters match or pattern has a '?', carry forward the result from previous row
                    curr[j] = prev[j - 1];
                } else if (p.charAt(j - 1) == '*') {
                    // '*' matches zero or more characters, so take the OR of:
                    // - Matching zero characters (i.e., skip the '*' in the pattern)
                    // - Matching one character (i.e., move to the next character in the string)
                    curr[j] = prev[j] || curr[j - 1];
                } else {
                    // If characters do not match and it's not a wildcard, set to false
                    curr[j] = false;
                }
            }

            // Swap prev and curr arrays for the next iteration
            boolean[] temp = prev;
            prev = curr;
            curr = temp;
        }

        return prev[m];  // The answer is stored in prev[m] after the last iteration
    }
}

